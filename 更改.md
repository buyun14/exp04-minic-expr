我们先了解一下当前的代码结构。


Ran tool
让我们先看一下词法分析器的代码，因为需要添加对八进制和十六进制的支持。


Ran tool
让我们先看一下语法分析器的代码，以了解当前的语法规则。


Ran tool
根据代码分析，我们需要进行以下修改：

1. 修改词法分析器以支持八进制和十六进制数字
2. 修改语法规则以支持乘除和求余运算
3. 修改语法规则以支持单目求负运算
4. 修改中间代码生成以支持新的运算
5. 修改ARM32后端以支持新的运算

让我们一步一步来实现这些功能。

首先，让我们修改词法分析器以支持八进制和十六进制数字：



现在让我们修改语法规则以支持乘除和求余运算，以及单目求负运算：



现在让我们修改词法分析器以支持新的运算符：



现在让我们修改AST节点类型以支持新的运算符：


Search files...
让我们修改AST节点类型以支持新的运算符。我将在`frontend/AST.h`中添加新的运算符类型：



现在让我们更新`frontend/Graph.cpp`中的节点名称映射，以支持新的运算符：



现在让我们更新IR生成器以支持新的运算符。我们需要在`ir/Generator/IRGenerator.h`中添加新的处理函数：



现在让我们在`ir/Generator/IRGenerator.cpp`中实现这些新的IR生成函数，并更新构造函数中的处理器映射：



现在我们已经完成了对AST节点类型和IR生成器的修改，以支持新的运算符。这些修改包括：

1. 在`AST.h`中添加了新的运算符类型：
   - `AST_OP_MUL`：乘法运算符
   - `AST_OP_DIV`：除法运算符
   - `AST_OP_MOD`：取模运算符
   - `AST_OP_NEG`：一元取负运算符

2. 在`Graph.cpp`中添加了新运算符的节点名称映射，用于可视化AST。

3. 在`IRGenerator.h`中添加了新的IR生成处理函数声明：
   - `ir_mul`：处理乘法运算
   - `ir_div`：处理除法运算
   - `ir_mod`：处理取模运算
   - `ir_neg`：处理一元取负运算

4. 在`IRGenerator.cpp`中：
   - 在构造函数中添加了新运算符的处理函数映射
   - 实现了新的IR生成处理函数，每个函数都遵循相同的模式：
     1. 获取操作数
     2. 创建相应的IR指令
     3. 将指令添加到模块中
     4. 设置结果值

这些修改使得编译器现在能够处理更复杂的算术表达式，包括：
- 乘法和除法运算
- 取模运算
- 一元取负运算

接下来，我们需要确保IR指令类（`Instruction`）支持这些新的操作。让我们检查一下IR指令的定义：


Search files...
我们需要在`ir/Instruction.h`中添加新的IR指令操作码：



现在让我们更新`ir/Instructions/BinaryInstruction.cpp`以支持新的二元运算符：



现在让我们创建一个新的`UnaryInstruction`类来处理一元取负操作：





现在我们已经完成了所有必要的修改，以支持新的运算符。让我们总结一下所做的更改：

1. 在`AST.h`中添加了新的运算符类型：
   - `AST_OP_MUL`：乘法运算符
   - `AST_OP_DIV`：除法运算符
   - `AST_OP_MOD`：取模运算符
   - `AST_OP_NEG`：一元取负运算符

2. 在`Graph.cpp`中添加了新运算符的节点名称映射，用于可视化AST。

3. 在`IRGenerator.h`中添加了新的IR生成处理函数声明：
   - `ir_mul`：处理乘法运算
   - `ir_div`：处理除法运算
   - `ir_mod`：处理取模运算
   - `ir_neg`：处理一元取负运算

4. 在`IRGenerator.cpp`中：
   - 在构造函数中添加了新运算符的处理函数映射
   - 实现了新的IR生成处理函数，每个函数都遵循相同的模式：
     1. 获取操作数
     2. 创建相应的IR指令
     3. 将指令添加到模块中
     4. 设置结果值

5. 在`Instruction.h`中添加了新的IR指令操作码：
   - `IRINST_OP_MUL_I`：整数乘法指令
   - `IRINST_OP_DIV_I`：整数除法指令
   - `IRINST_OP_MOD_I`：整数取模指令
   - `IRINST_OP_NEG_I`：整数取负指令

6. 在`BinaryInstruction.cpp`中添加了对新二元运算符的支持：
   - 乘法（mul）
   - 除法（div）
   - 取模（mod）

7. 创建了新的`UnaryInstruction`类来处理一元取负操作：
   - 实现了构造函数和`toString`方法
   - 支持一元取负操作（neg）

这些修改使得编译器现在能够处理更复杂的算术表达式，包括：
- 乘法和除法运算
- 取模运算
- 一元取负运算

接下来，我们需要确保ARM32后端能够正确处理这些新的IR指令。让我们检查一下ARM32指令选择器的代码：


Search files...
让我们更新ARM32指令选择器以支持新的运算符。首先，我们需要在`InstSelectorArm32.h`中添加新的处理函数声明：



现在让我们在`InstSelectorArm32.cpp`中实现这些新的处理函数，并更新构造函数中的处理器映射：



我们已经完成了所有必要的修改，以支持新的运算符。让我们总结一下所做的更改：

1. 在`AST.h`中添加了新的运算符类型：
   - `AST_OP_MUL`：乘法运算符
   - `AST_OP_DIV`：除法运算符
   - `AST_OP_MOD`：取模运算符
   - `AST_OP_NEG`：一元取负运算符

2. 在`Graph.cpp`中添加了新运算符的节点名称映射，用于可视化AST。

3. 在`IRGenerator.h`中添加了新的IR生成处理函数声明：
   - `ir_mul`：处理乘法运算
   - `ir_div`：处理除法运算
   - `ir_mod`：处理取模运算
   - `ir_neg`：处理一元取负运算

4. 在`IRGenerator.cpp`中：
   - 在构造函数中添加了新运算符的处理函数映射
   - 实现了新的IR生成处理函数，每个函数都遵循相同的模式：
     1. 获取操作数
     2. 创建相应的IR指令
     3. 将指令添加到模块中
     4. 设置结果值

5. 在`Instruction.h`中添加了新的IR指令操作码：
   - `IRINST_OP_MUL_I`：整数乘法指令
   - `IRINST_OP_DIV_I`：整数除法指令
   - `IRINST_OP_MOD_I`：整数取模指令
   - `IRINST_OP_NEG_I`：整数取负指令

6. 在`BinaryInstruction.cpp`中添加了对新二元运算符的支持：
   - 乘法（mul）
   - 除法（div）
   - 取模（mod）

7. 创建了新的`UnaryInstruction`类来处理一元取负操作：
   - 实现了构造函数和`toString`方法
   - 支持一元取负操作（neg）

8. 在ARM32指令选择器中添加了对新运算符的支持：
   - 在`InstSelectorArm32.h`中添加了新的处理函数声明
   - 在`InstSelectorArm32.cpp`中实现了新的处理函数：
     - `translate_mul_int32`：使用ARM32的`mul`指令
     - `translate_div_int32`：使用ARM32的`__aeabi_idiv`函数
     - `translate_mod_int32`：使用ARM32的`__aeabi_idivmod`函数
     - `translate_neg_int32`：使用ARM32的`rsb`指令

这些修改使得编译器现在能够处理更复杂的算术表达式，包括：
- 乘法和除法运算
- 取模运算
- 一元取负运算

对于ARM32后端，我们使用了以下策略：
1. 乘法和取负操作使用ARM32的原生指令
2. 除法和取模操作使用ARM32的运行时库函数，因为这些操作在ARM32上比较复杂，需要特殊的处理

现在编译器应该能够正确处理所有这些新的运算符，并生成正确的ARM32汇编代码。
